# 通讯协议

* 发送窗口：发送方已发送但尚未被确认的帧的序号队列的界限，其上下界分别为窗口的上下沿，上下沿的距离为窗口尺寸
* 公平退让法则：发送窗口大小取决于发送缓存大小、接收端剩余接收缓存大小、丢包退让和慢启动四要素决定。
* RTT：一个报文段发送出去，到收到对应确认包的时间差。
## MTU（Maximum Transmission Unit, 最大传输单元）：能通过最大数据包字节数

* 以太网 MTU=1500 bytes；P2P MTU=4470 bytes
  * 假设发送者的协议高层向IP层发送了长度为3008 bytes的数据报文，则该报文在添加20 bytes的IP包头后IP包的总长度是 3028 bytes，因为3028 > 1500，所以该数据报文将被分片，
  * 注意：分片时仅仅对上层的数据进行分片，不需要对原来的IP首部分片，所以要分片的数据长度只有3008，而不是3028. 这特别容易出错。
  * 分片过程如下：
    * 首先计算最大的IP包中IP净荷的长度 =MTU-IP包头长度=1500-20= 1480 bytes。
    * 然后把3008 bytes按照1480 bytes的长度分片，将要分为3片，3008= 1480+1480+48。
    * 最后发送者将为3个分片分别添加IP包头，组成3个IP包后再发送，3个IP包的长度分别为1500 bytes、1500 bytes和 68 bytes。
  * 在网络通讯中，需要尽量避免发生分片和重组，因为分片重组对网络性能影响较大。
    * MTU大小的选择有协议协商方式，通过全路径的MTU发现机制，找到整条路径的最小MTU（也就是路径MTU），然后报文发送式小于等于路径MTU，这就避免了数据传输过程中产生分片，从而提高数据转发性能。
    * MTU的协议发现机制由于安全等方面的原因，并不能总是生效，这时候就需要根据网络的特性选择合理的MTU。如果在报文传送过程中分片是不可避免的，那么要想办法让重组尽量在终端进行，避免在转发路径中进行。

### 检测网关 MTU

```shell
sh$ ping -f -s 1472 192.168.0.1 # -l 1472 数据报长度，若能ping通表示不需要拆包；若出现 Packet needs to be fragmented by DF set.
```

### 修改 MTU

```shell
sh$ ifconfig eth0 mtu 1460
```

## OSI 7

* Please Do Not Throw Sussi and Pizza Away
* Physical Data-Link Network Transport Session Presentation Application

### 5, Session Layer

* RPC 远程过程调用协议
* SSL & TLS

### 4, Transport Layer

* UDP 用户数据报协议
  * KCP 基于UDP的ARQ协议
    * ARQ: Automatic Repeat-reQuest 是 OSI 模型中 Data-Link 层的纠错协议
    * RTO: Retransmission Timeout
    * FEC: Forward Error Correction
* TCP 传输控制协议

#### KCP

TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而KCP 是为流速设计的（单个数据包从一端发送到一端需要多少时间），以比TCP高 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。连时钟都需要外部传递进来，内部不会有任何一次系统调用。

整个协议只有 ikcp.h, ikcp.c两个源文件，可以方便的集成到用户自己的协议栈中。也许你实现了一个P2P，或者某个基于 UDP的协议，而缺乏一套完善的ARQ可靠协议实现，那么简单的拷贝这两个文件到现有项目中，稍微编写两行代码，即可使用。

KCP的发送机制采用TCP的滑动窗口方式，可以非常容易的控制流量。KCP的头中包含wnd，即接收方目前可以接收的大小。

* RTO（Recovery Time Object, 恢复时间目标
  * TCP timeout = RTO *2，连续丢包3次，就变成 RTO*8
  * KCP timeout = RTO*1.5
* 重传机制
  * TCP 丢包后从丢包开始之后的数据全部重传
  * KCP 只重传真正丢失的包
* 快速重传
  * 发送包1,2,3,4,5，收到ACK:1,3,4,5；当收到ACK 3时，KCP 知道包2跳过一次；收到ACK 4时，知道包2跳过了两次，此时认为包2丢失，不用等超时立即重传包2。
* 延迟ACK
  * TCP 为了充分利用带宽，会延迟发送ACK（No delay都没用），这样超时会有较大的 RTT（Round-Trip Time）， 延长了丢包判断过程。KCP ACK 是否延迟发送可以调节
* 非退让流控
  * KCP 和 TCP 一样使用公平退让法则。而传输及时性高的小数据，可配置跳过丢包退让和慢启动，仅用发送缓存大小、接收端剩余接受缓存大小来控制发送频率。以牺牲部分公平性机带宽利用率，换取了开着BT都能流畅传输的效果。

### 3, Network Layer

* IP/IPv6
* ICMP/ICMPv6 互联网控制信息协议
  * TCP/IP协议族的一个子协议，用于在IP主机和路由器传递控制信息，包括报告错误、交换受限控制和状态信息等
  * Ping of Death: 利用操作系统规定的ICMP数据包最大尺寸不超过64KB，如果ICMP数据包的尺寸超过64KB上限时，主机就会出现内存分配错误，导致TCP/IP堆栈崩溃，致使主机死机。（操作系统已经取消了发送ICMP数据包的大小的限制，解决了这个漏洞）。
    * 防护一：在路由器上对ICMP数据包进行带宽限制，将ICMP占用的带宽控制在一定的范围内，这样即使有ICMP攻击，它所占用的带宽也是非常有限的，对整个网络的影响非常少；
    * 防护二：在主机上设置ICMP数据包的处理规则，最好是设定拒绝所有的ICMP数据包。
  * ICMP风暴：向目标主机长时间、连续、大量地发送ICMP数据包，也会最终使系统瘫痪。大量的ICMP数据包会形成“ICMP风暴”，使得目标主机耗费大量的CPU资源处理，疲于奔命。
* IGMP  互联网组管理协议