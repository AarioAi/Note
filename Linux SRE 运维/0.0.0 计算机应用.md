# 计算机应用

算法是求解某类问题的通用法则或方法。

世界上第一台**冯·诺依曼存储程序体系**结构的计算机是英国剑桥大学的EDSAC（Electronic Delay Storage Automatic Calculator）。

* 1940-1960 第一代**电子管**计算机，存储器为声延迟线或磁鼓。使用机器语言和汇编语言。
* 1954-1964 第二代**晶体管**计算机，内存采用磁芯，外存采用磁鼓与磁带，实现了浮点运算，提出中断、变址概念，开始使用高级语言。
  * 1954年，第一个高级语言 Fortran I诞生。之后诞生了第一个结构化语言Pascal。
* 1964-1975 第三代**集成电路**计算机。
  * 1973年，C语言诞生。
* 1975至今   第四代**大规模、超大规模集成电路**计算机。

* 1952-1969 面向终端的计算机网络，终端控制器实现了终端访问的控制和数据指令收发。
* 1969-1974 面向通信子网的计算机网络，Package Switching 分组交换将报文分割成子报文（Pakage），每个子报文都有源地址和目标地址，独立选择发送路径。现代计算机网络鼻祖阿帕网（ARPANET）也是第一个分组交换网络，故ARPANET是分组交换和Internet的鼻祖。
* 1974-1993 结构标准化计算机网络，OSI模型诞生
* 1993至今   互联高速移动泛在的计算机网络，如物联网等移动泛在网络。

数据总线（Data Bus）：CPU向各个部件传输数据的共用信号线，总线位数和CPU位数对应。双向、三态总线，即数据可以从CPU发出，也可以传入CPU。
地址总线（Address Bus）：CPU发出单向、三态总线。
控制总线（Control Bus）：双向

只有机器语言能被计算机**硬件**直接识别和执行，语句都是由0/1二进制代码组成的程序设计语言。

编译（Compile）型高级语言需要将源程序翻译成目标程序，将目标程序链接成可执行程序。解释（Interpret）型高级语言边分析边执行，不产生目标程序。

* 十六进制转二进制：Ox3BF.6A  == Bx0011 1011 1111.0110 1010
* 二进制转十六机制：Bx111011111.0110101  ===> Bx0011 1011 1111.0110 1010 ==> 0x3BF.6A

## 二进制数

**机器数**指数在计算机内的表达形式。

* **原码**：最左边一位是*符号位*0表示正数，1表示负数。其他位表示数大小。
* **反码**：正数跟原码一样，负数符号位仍为1，其他位取反。
* **补码**：正数跟原码一样，负数符号位仍为1，其他位取反，再加1。即 $X_补 = X_反 + 1$
  * 补码可以把减法运算转换成加法运算

* **定点小数**：固定位置位整数，固定位置为小数。
* **浮点小数**：$N = (-1)^s * M * 2^E, s=0|1, M 是二进制定点小数，E是整数$
  * $-1010011$ == $-0.1010011 * 2^7$

## BIOS

RAM芯片是读写存储器，ROM（Read Only Memory）只读存储器。

BIOS(Basic Input Output System) 是固化在ROM芯片中的一组程序。ROM存储器：

* EPROM：可擦除、可编程ROM。芯片中央有个透明窗口，可用紫外线将芯片信息擦除掉，即将EPROM中所有存储位都变成1。
* EEPROM：可电擦除、可编程ROM。需要写入时，在引脚加上高电压即可快速写入或擦除。

计算机组件配置参数都存放在一块CMOS RAM芯片，系统有后备电池向CMOS持续供电。习惯上说设置BIOS，其实是设置CMOS。

### 计算机启动过程

1. 电源开始供电，此时电压不稳，当主板认为电压没有达到CMOS配置中CPU主频电压，就会向CPU发出RESET信号。当达到稳定电压，RESET信号撤销，CPU立即从基本内存的BIOS段读取一条跳转指令，跳转到BIOS启动代码处。
2. POST（Power On Self Test）加电自检程序，主要是BIOS用于检测CPU、内存、扩展内存、ROM、主板、CMOS存储器、串口、并口、显卡、硬盘及键盘等。
3. 自检通过后，系统BIOS会找到显卡BIOS，并调用显卡BIOS初始代码，此时显示器就显示显卡相关信息。
4. 完成POST之后，BIOS进按照CMOS配置启动顺序启动操作系统，然后将系统控制权交给引导程序。操作系统从执行引导程序开始完成内核加载和初始化。
BIOS包含中断服务程序，当系统需要并发调用不同硬件时，BIOS可以调用中断服务来实现对硬件的控制和使用。

## 操作系统

操作系统五大功能：

* **进程管理**
* **存储器管理**
* **设备管理**
* **文件管理**
* **用户接口**

UNIX 是第一代**网络**操作系统，它是多用户的，所实现的功能位于OSI模型传输层以上。TCP/IP已成为UNIX基本组成部分。Linux 是基于POSIX的类UNIX操作系统。Windows是基于图形用户界面的操作系统。

## 编译器

**程序设计语言**是人与计算机交流的语言，包括机器语言、汇编语言和高级语言。

```txt
                                                     [优化器]
                                                        |
源代码.c --> [词法分析] --> [语法分析] --> [语义分析] --> [代码生成] --汇编代码--> 汇编文件.s
                             |             |            |
                        [                符号表               ]
```

### 词法分析：标识符、保留字、运算符、分界符

```c
void main() {
    int a = 1;
}
```

> 1、void 保留字；2、main标识符；3、(；4、)；5、{；6、int 保留字；7、a 标识符；8、= 赋值符；9、1 整数；10、;；11、}

### 语法分析

```txt
a = 10 + b * 20

标识符（a） = 10 + 表达式（标识符（b）* 20）
  
```

### 语义分析

如 `a+b` 分析到`+`操作，就要分析`a`、`b`是否声明、类型是否兼容等。

### 中间代码生成

编译系统通常采用“四元码”等中间代码，形式（运算符 对象1 对象2 结果），如 `a = 10 + b * 20`：

```txt
(* b 20 tl)
(+ 10 tl t2)
(= t2 a)
```

### 代码优化

 ```txt
 (* b 20 tl)
(+ 10 tl a)
 ```

### 目标代码生成

```s
mov R1 , b    // move b to register R1
mul R1 , 20   // R1 *= 20
mov R2 , 10
add R1 , R2   / R1 += R2
mov a , R1
```

若编译器生成的代码只能运行在与编译器同环境平台上，称该编译器为**本地编译器**；跨平台的称为**交叉编译器**。

### 机器语言

汇编语言与机器语言几乎是一一对应的，汇编语言可以直接访问寄存器或内存，执行速度快，却难以移植。汇编语言一般用户操作系统引导程序、BIOS中断处理程序、单片机控制程序等。

```txt
1011 1000 0000 0100 0000 0000   // mov ax , 4
1011 1011 0000 0101 0000 0000   // mov bx , 5
1111 0111 1110 0011             // mul bx
```

高级语言的特点：形式化、接近自然语言、容易移植、开发高效。面向对象程序特点是：支持类、对象、继承、封装、多态。

## 计算机网络

* MODEM（Modulator and Demodulator 调制解调器）：用户转换数字信号和模拟信号。物理层和链路层设备。
* NIC（Network Interface Card，网卡）：每个网卡都有物理地址，又称MAC（Media Access Conrol，介质访问控制）地址。物理层和链路层设备
* HUB 集线器（即中心的意思）：局域网物理层设备，对接收到信号再生、整形和放大。
* Switch 交换机：实现数据从一个端口转发到另外一个端口，属于局域网数据链路层设备。
* Router 路由器：实现数据从一个网络转发到另外一个网络，属于网络层设备。

> 网卡或者MODEM即是OSI物理层设备，也是数据链路层设备。

OSI 是个概念框架，后来被TCP/IP模型取代，OSI七层模型（PDNTSPA）：

* 物理层 Physical Layer：0/1比特流发送和接收，不关心数据意义和差错。如RS232、RS485协议都是物理层协议。一般由网卡或MODEM实现。
* 数据链路层 Data Link Layer：处理物理层0/1比特流差错和同步，帧（Frame）是数据链路层协议数据单元，数据帧包括起始标志、结束标志、控制信息和纠错检错信息等。数据链路层主要以数据帧等形式无差错地传输数据。数据链路层一般也是由网卡或MODEL实现。
* 网络层 Network Layer：报文分组打包或重组、报文路由选择、流量控制和地址解析等。**OSI模型网络层支持面向连接和面向无连接对通信，在传输层仅又面向连接的通信**。
* 传输层 Transport Layer：以完整报文为单位，End to End（端到端）地传输数据。End to End 实现跨进程通信。
* 会话层 Session Layer：会话建立、连接和释放
* 表示层 Presentation Layer：将用户或应用层请求表示层OSI语法，同时完成压缩和加密。
* 应用层 Application Layer

PDNT 层都传输数据，SPA层不参与数据传输。

### TCP/IP模型

TCP/IP是由上百个协议组成等协议簇，

TCP/IP 四层模型（INTA）：

* 网络接口层：
* 网络层：IP、ICMP、ARP（Address Resolution Protocol，地址解析协议）。**TCP/IP模型中，IP是无连接、不可靠对网络协议，因此IP分组到达可能存在丢包现象，需要通过传输层协议来处理**。
* 传输层：TCP（传输控制协议）和UDP（User Datagram Protocol，用户数据报协议），提供端对端END to End面向连接或无连接的网络传输服务。
  * UDP 是无连接的，不存在长连接
* 应用层：


* virus 计算机病毒：寄宿在其他程序上，能传播、感染其他系统
* worms 蠕虫：利用系统漏洞进行自我传播的恶意程序。独立存在，不需要寄宿在其他程序上。
* trojan horse 特诺伊木马：不会繁殖、不会感染，通过伪装吸引用户下载，让主机成为肉鸡。


* BMP（bitmap）位图，无压缩
* GIF：无损压缩，压缩率50%
* PNG：无损压缩
* JPEG：有损压缩
* TIFF：扫描、传真、文字处理图片格式
* SVG：矢量图形，文件很小